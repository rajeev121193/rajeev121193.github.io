{"ast":null,"code":"import { PathSplitter } from \"./PathSplitter\";\nexport function OptimizeSvg(inputFileUrl, callback) {\n  var request = new XMLHttpRequest();\n  request.open(\"GET\", inputFileUrl);\n  request.setRequestHeader(\"Content-Type\", \"image/svg+xml\");\n  request.addEventListener(\"load\", function (event) {\n    var response = event.target.responseText;\n    var doc = new DOMParser();\n    var xml = doc.parseFromString(response, \"image/svg+xml\"); //This is to convert HTML collection to JS Array\n\n    const allPaths = [...xml.getElementsByTagName(\"path\")];\n    const oldPathToNewPathsMap = {};\n    allPaths.forEach((path, index) => {\n      if (index < 2) {\n        const parentNode = path.parentNode;\n        const newPaths = [];\n        PathSplitter(path.getAttribute(\"d\")).forEach(pathDataPart => {\n          const newPath = path.cloneNode(true);\n          newPath.setAttribute(\"d\", pathDataPart); // parentNode.insertBefore(newPath, path);\n\n          newPaths.push(newPath);\n        });\n        oldPathToNewPathsMap[`path${index}`] = {\n          oldPathNode: path,\n          parentNode,\n          newPaths\n        }; // parentNode.removeChild(path);\n      }\n    });\n    Object.keys(oldPathToNewPathsMap).forEach(key => {\n      const {\n        oldPathNode,\n        parentNode,\n        newPaths\n      } = oldPathToNewPathsMap[key];\n      newPaths.forEach(newPathNode => {\n        parentNode.insertBefore(newPathNode, oldPathNode);\n      });\n      parentNode.removeChild(oldPathNode);\n    }); //Convert the new XML document to svg string\n\n    var svgData = new XMLSerializer().serializeToString(xml);\n    callback(svgData);\n  });\n  return request.send();\n}\n_c = OptimizeSvg;\n\nvar _c;\n\n$RefreshReg$(_c, \"OptimizeSvg\");","map":{"version":3,"sources":["/Users/mkumar18/dev/tools/svg-path-splitter/src/OptimizeSvg.js"],"names":["PathSplitter","OptimizeSvg","inputFileUrl","callback","request","XMLHttpRequest","open","setRequestHeader","addEventListener","event","response","target","responseText","doc","DOMParser","xml","parseFromString","allPaths","getElementsByTagName","oldPathToNewPathsMap","forEach","path","index","parentNode","newPaths","getAttribute","pathDataPart","newPath","cloneNode","setAttribute","push","oldPathNode","Object","keys","key","newPathNode","insertBefore","removeChild","svgData","XMLSerializer","serializeToString","send"],"mappings":"AAAA,SAAQA,YAAR,QAA2B,gBAA3B;AAEA,OAAO,SAASC,WAAT,CAAqBC,YAArB,EAAmCC,QAAnC,EAA6C;AAChD,MAAIC,OAAO,GAAG,IAAIC,cAAJ,EAAd;AACAD,EAAAA,OAAO,CAACE,IAAR,CAAa,KAAb,EAAoBJ,YAApB;AACAE,EAAAA,OAAO,CAACG,gBAAR,CAAyB,cAAzB,EAAyC,eAAzC;AACAH,EAAAA,OAAO,CAACI,gBAAR,CAAyB,MAAzB,EAAiC,UAASC,KAAT,EAAgB;AAC7C,QAAIC,QAAQ,GAAGD,KAAK,CAACE,MAAN,CAAaC,YAA5B;AACA,QAAIC,GAAG,GAAG,IAAIC,SAAJ,EAAV;AACA,QAAIC,GAAG,GAAGF,GAAG,CAACG,eAAJ,CAAoBN,QAApB,EAA8B,eAA9B,CAAV,CAH6C,CAK7C;;AACA,UAAMO,QAAQ,GAAG,CAAC,GAAGF,GAAG,CAACG,oBAAJ,CAAyB,MAAzB,CAAJ,CAAjB;AACA,UAAMC,oBAAoB,GAAG,EAA7B;AACAF,IAAAA,QAAQ,CAACG,OAAT,CAAiB,CAACC,IAAD,EAAOC,KAAP,KAAiB;AAC9B,UAAIA,KAAK,GAAG,CAAZ,EAAe;AACX,cAAMC,UAAU,GAAGF,IAAI,CAACE,UAAxB;AACA,cAAMC,QAAQ,GAAG,EAAjB;AACAxB,QAAAA,YAAY,CAACqB,IAAI,CAACI,YAAL,CAAkB,GAAlB,CAAD,CAAZ,CAAqCL,OAArC,CAA6CM,YAAY,IAAI;AACzD,gBAAMC,OAAO,GAAGN,IAAI,CAACO,SAAL,CAAe,IAAf,CAAhB;AACAD,UAAAA,OAAO,CAACE,YAAR,CAAqB,GAArB,EAA0BH,YAA1B,EAFyD,CAGzD;;AACAF,UAAAA,QAAQ,CAACM,IAAT,CAAcH,OAAd;AACH,SALD;AAMAR,QAAAA,oBAAoB,CAAE,OAAMG,KAAM,EAAd,CAApB,GAAuC;AACnCS,UAAAA,WAAW,EAAEV,IADsB;AAEnCE,UAAAA,UAFmC;AAGnCC,UAAAA;AAHmC,SAAvC,CATW,CAcX;AACH;AACJ,KAjBD;AAmBAQ,IAAAA,MAAM,CAACC,IAAP,CAAYd,oBAAZ,EAAkCC,OAAlC,CAA0Cc,GAAG,IAAI;AAC7C,YAAM;AAACH,QAAAA,WAAD;AAAcR,QAAAA,UAAd;AAA0BC,QAAAA;AAA1B,UAAsCL,oBAAoB,CAACe,GAAD,CAAhE;AACAV,MAAAA,QAAQ,CAACJ,OAAT,CAAiBe,WAAW,IAAI;AAC5BZ,QAAAA,UAAU,CAACa,YAAX,CAAwBD,WAAxB,EAAqCJ,WAArC;AACH,OAFD;AAGAR,MAAAA,UAAU,CAACc,WAAX,CAAuBN,WAAvB;AACH,KAND,EA3B6C,CAmC7C;;AACA,QAAIO,OAAO,GAAG,IAAIC,aAAJ,GAAoBC,iBAApB,CAAsCzB,GAAtC,CAAd;AACAZ,IAAAA,QAAQ,CAACmC,OAAD,CAAR;AACH,GAtCD;AAuCA,SAAOlC,OAAO,CAACqC,IAAR,EAAP;AACH;KA5CexC,W","sourcesContent":["import {PathSplitter} from \"./PathSplitter\";\n\nexport function OptimizeSvg(inputFileUrl, callback) {\n    var request = new XMLHttpRequest();\n    request.open(\"GET\", inputFileUrl);\n    request.setRequestHeader(\"Content-Type\", \"image/svg+xml\");\n    request.addEventListener(\"load\", function(event) {\n        var response = event.target.responseText;\n        var doc = new DOMParser();\n        var xml = doc.parseFromString(response, \"image/svg+xml\");\n\n        //This is to convert HTML collection to JS Array\n        const allPaths = [...xml.getElementsByTagName(\"path\")];\n        const oldPathToNewPathsMap = {};\n        allPaths.forEach((path, index) => {\n            if (index < 2) {\n                const parentNode = path.parentNode;\n                const newPaths = [];\n                PathSplitter(path.getAttribute(\"d\")).forEach(pathDataPart => {\n                    const newPath = path.cloneNode(true);\n                    newPath.setAttribute(\"d\", pathDataPart);\n                    // parentNode.insertBefore(newPath, path);\n                    newPaths.push(newPath);\n                });\n                oldPathToNewPathsMap[`path${index}`] = {\n                    oldPathNode: path,\n                    parentNode,\n                    newPaths\n                };\n                // parentNode.removeChild(path);\n            }\n        });\n\n        Object.keys(oldPathToNewPathsMap).forEach(key => {\n            const {oldPathNode, parentNode, newPaths} = oldPathToNewPathsMap[key];\n            newPaths.forEach(newPathNode => {\n                parentNode.insertBefore(newPathNode, oldPathNode);\n            });\n            parentNode.removeChild(oldPathNode);\n        });\n\n        //Convert the new XML document to svg string\n        var svgData = new XMLSerializer().serializeToString(xml);\n        callback(svgData)\n    });\n    return request.send();\n}"]},"metadata":{},"sourceType":"module"}