[{"/Users/mkumar18/dev/tools/svg-path-splitter/src/index.js":"1","/Users/mkumar18/dev/tools/svg-path-splitter/src/App.js":"2","/Users/mkumar18/dev/tools/svg-path-splitter/src/reportWebVitals.js":"3","/Users/mkumar18/dev/tools/svg-path-splitter/src/PathSplitter.js":"4","/Users/mkumar18/dev/tools/svg-path-splitter/src/Images.js":"5","/Users/mkumar18/dev/tools/svg-path-splitter/src/OptimizeSvg.js":"6"},{"size":510,"mtime":1618539371554,"results":"7","hashOfConfig":"8"},{"size":348,"mtime":1618542530888,"results":"9","hashOfConfig":"8"},{"size":448,"mtime":1618539371657,"results":"10","hashOfConfig":"8"},{"size":6915,"mtime":1618501836771,"results":"11","hashOfConfig":"8"},{"size":3989,"mtime":1618544133673,"results":"12","hashOfConfig":"8"},{"size":2505,"mtime":1618543732861,"results":"13","hashOfConfig":"8"},{"filePath":"14","messages":"15","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"1w8onak",{"filePath":"16","messages":"17","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"18","messages":"19","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"20","messages":"21","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"22","usedDeprecatedRules":"23"},{"filePath":"24","messages":"25","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"26","messages":"27","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"/Users/mkumar18/dev/tools/svg-path-splitter/src/index.js",[],"/Users/mkumar18/dev/tools/svg-path-splitter/src/App.js",[],"/Users/mkumar18/dev/tools/svg-path-splitter/src/reportWebVitals.js",[],"/Users/mkumar18/dev/tools/svg-path-splitter/src/PathSplitter.js",["28","29"],"/**\n * Reference - https://gist.github.com/iconifyit/958e7abba71806d663de6c2c273dc0da\n * This script was taken from a discussion on Google Groups.\n * I'm not taking credit for it but sharing it because it is very useful for splitting\n * discontinuous absolute paths into continuous subpaths. Where this is particularly\n * useful is for importing SVG files into applications like Figma, Sketch, InVision, XD, etc.\n */\n/**\n * Split discontinuous absolute paths into continuous sub-paths.\n *\n *     Example:\n *\n *     console.log(PathSplitter(\n *         \"M.75,17.25a16.5,16.5,0,0,1,27-12.73\" +\n *         \"m4.88,6.73a16.63,16.63,0,0,1,1.12,6v12a16.5,16.5,0,0,1-16.5,16.5,16.82,16.82,0,0,1-3-.27\" +\n *         \"M6.75,42a16.49,16.49,0,0,1-6-12.73v-4.5\" +\n *         \"m24,4.5v-12a7.5,7.5,0,0,0-12-6\" +\n *         \"m-3,6v12a7.51,7.51,0,0,0,10.5,6.88\" +\n *         \"-3-17.38v9\"\n *     ));\n *\n *     Returns:\n *\n *     [\n *         M 0.75 17.25 a 16.5 16.5 0 0 1 27 -12.73,\n *         M 32.63 11.25 a 16.63 16.63 0 0 1 1.12 6 v 12 a 16.5 16.5 0 0 1 -16.5 16.5 a 16.82 16.82 0 0 1 -3 -0.27,\n *         M 6.75 42 a 16.49 16.49 0 0 1 -6 -12.73 v -4.5,\n *         M 24.75 29.27 v -12 a 7.5 7.5 0 0 0 -12 -6,\n *         M 9.75 17.27 v 12 a 7.51 7.51 0 0 0 10.5 6.88,\n *         M 17.25 18.77 v 9\n *     ]\n * @param   {string}    pathData    The SVG path data string.\n * @returns {Array}\n * @constructor\n */\nexport function PathSplitter(pathData) {\n    function paths(ps) {\n        var p = (paths.ps = paths.ps || {});\n        if (p[ps]) {\n            p[ps].sleep = 100;\n        } else {\n            p[ps] = {\n                sleep: 100\n            };\n        }\n        setTimeout(function () {\n            for (var key in p)\n                if (p.hasOwnProperty(key) && key !== ps) {\n                    p[key].sleep--;\n                    !p[key].sleep && delete p[key];\n                }\n        });\n        return p[ps];\n    }\n\n    function clone(obj) {\n        if (typeof obj == \"function\" || Object(obj) !== obj) {\n            return obj;\n        }\n        var res = new obj.constructor();\n        for (var key in obj)\n            if (obj.hasOwnProperty(key)) {\n                res[key] = clone(obj[key]);\n            }\n        return res;\n    }\n\n    function pathClone(pathArray) {\n        var res = clone(pathArray);\n        res.toString = toString;\n        return res;\n    }\n\n    function parsePathString(pathString) {\n        if (!pathString) {\n            return null;\n        }\n        var pth = paths(pathString);\n        if (pth.arr) {\n            return pathClone(pth.arr);\n        }\n\n        var paramCounts = {\n                a: 7,\n                c: 6,\n                o: 2,\n                h: 1,\n                l: 2,\n                m: 2,\n                r: 4,\n                q: 4,\n                s: 4,\n                t: 2,\n                v: 1,\n                u: 3,\n                z: 0\n            },\n            data = [];\n        if (Array.isArray(pathString) && Array.isArray(pathString[0])) {\n            // rough assumption\n            data = pathClone(pathString);\n        }\n        if (!data.length) {\n            const pathCommand = /([a-z])[\\s,]*((-?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?[\\s]*,?[\\s]*)+)/gi;\n            const pathValues = /(-?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?)[\\s]*,?[\\s]*/gi;\n            String(pathString).replace(pathCommand, function (a, b, c) {\n                var params = [],\n                    name = b.toLowerCase();\n                c.replace(pathValues, function (a, b) {\n                    b && params.push(+b);\n                });\n                if (name === \"m\" && params.length > 2) {\n                    data.push([b].concat(params.splice(0, 2)));\n                    name = \"l\";\n                    b = b === \"m\" ? \"l\" : \"L\";\n                }\n                if (name === \"o\" && params.length === 1) {\n                    data.push([b, params[0]]);\n                }\n                if (name === \"r\") {\n                    data.push([b].concat(params));\n                } else\n                    while (params.length >= paramCounts[name]) {\n                        data.push(\n                            [b].concat(params.splice(0, paramCounts[name]))\n                        );\n                        if (!paramCounts[name]) {\n                            break;\n                        }\n                    }\n            });\n        }\n        data.toString = paths.toString;\n        pth.arr = pathClone(data);\n        return data;\n    }\n\n    function pathToAbsoluteSubPaths(path_string) {\n        var path_commands = parsePathString(path_string),\n            end_point = [0, 0],\n            sub_paths = [],\n            command = [],\n            i = 0;\n\n        while (i < path_commands.length) {\n            command = path_commands[i];\n            end_point = getNextEndPoint(end_point, command);\n            if (command[0] === \"m\") {\n                command = [\"M\", end_point[0], end_point[1]];\n            }\n            var sub_path = [command.join(\" \")];\n\n            i++;\n\n            while (!endSubPath(path_commands, i)) {\n                command = path_commands[i];\n                sub_path.push(command.join(\" \"));\n                end_point = getNextEndPoint(end_point, command);\n                i++;\n            }\n\n            sub_paths.push(sub_path.join(\" \"));\n        }\n\n        return sub_paths;\n    }\n\n    function getNextEndPoint(end_point, command) {\n        var x = end_point[0],\n            y = end_point[1];\n        if (isRelative(command)) {\n            switch (command[0]) {\n                case \"h\":\n                    x += command[1];\n                    break;\n                case \"v\":\n                    y += command[1];\n                    break;\n                case \"z\":\n                    // back to [0,0]?\n                    x = 0;\n                    y = 0;\n                    break;\n                default:\n                    x += command[command.length - 2];\n                    y += command[command.length - 1];\n            }\n        } else {\n            switch (command[0]) {\n                case \"H\":\n                    x = command[1];\n                    break;\n                case \"V\":\n                    y = command[1];\n                    break;\n                case \"Z\":\n                    // back to [0,0]?\n                    x = 0;\n                    y = 0;\n                    break;\n                default:\n                    x = command[command.length - 2];\n                    y = command[command.length - 1];\n            }\n        }\n        return [x, y];\n    }\n\n    function isRelative(command) {\n        return command[0] === command[0].toLowerCase();\n    }\n\n    function endSubPath(commands, index) {\n        if (index >= commands.length) {\n            return true;\n        } else {\n            return commands[index][0].toLowerCase() === \"m\";\n        }\n    }\n\n    return pathToAbsoluteSubPaths(pathData);\n}\n",["30","31"],"/Users/mkumar18/dev/tools/svg-path-splitter/src/Images.js",[],"/Users/mkumar18/dev/tools/svg-path-splitter/src/OptimizeSvg.js",[],{"ruleId":"32","severity":1,"message":"33","line":104,"column":65,"nodeType":"34","messageId":"35","endLine":104,"endColumn":66,"suggestions":"36"},{"ruleId":"32","severity":1,"message":"33","line":105,"column":50,"nodeType":"34","messageId":"35","endLine":105,"endColumn":51,"suggestions":"37"},{"ruleId":"38","replacedBy":"39"},{"ruleId":"40","replacedBy":"41"},"no-useless-escape","Unnecessary escape character: \\-.","Literal","unnecessaryEscape",["42","43"],["44","45"],"no-native-reassign",["46"],"no-negated-in-lhs",["47"],{"messageId":"48","fix":"49","desc":"50"},{"messageId":"51","fix":"52","desc":"53"},{"messageId":"48","fix":"54","desc":"50"},{"messageId":"51","fix":"55","desc":"53"},"no-global-assign","no-unsafe-negation","removeEscape",{"range":"56","text":"57"},"Remove the `\\`. This maintains the current functionality.","escapeBackslash",{"range":"58","text":"59"},"Replace the `\\` with `\\\\` to include the actual backslash character.",{"range":"60","text":"57"},{"range":"61","text":"59"},[3186,3187],"",[3186,3186],"\\",[3265,3266],[3265,3265]]