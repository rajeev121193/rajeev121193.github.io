{"ast":null,"code":"/**\n * Reference - https://gist.github.com/iconifyit/958e7abba71806d663de6c2c273dc0da\n * This script was taken from a discussion on Google Groups.\n * I'm not taking credit for it but sharing it because it is very useful for splitting\n * discontinuous absolute paths into continuous subpaths. Where this is particularly\n * useful is for importing SVG files into applications like Figma, Sketch, InVision, XD, etc.\n */\n\n/**\n * Split discontinuous absolute paths into continuous sub-paths.\n *\n *     Example:\n *\n *     console.log(PathSplitter(\n *         \"M.75,17.25a16.5,16.5,0,0,1,27-12.73\" +\n *         \"m4.88,6.73a16.63,16.63,0,0,1,1.12,6v12a16.5,16.5,0,0,1-16.5,16.5,16.82,16.82,0,0,1-3-.27\" +\n *         \"M6.75,42a16.49,16.49,0,0,1-6-12.73v-4.5\" +\n *         \"m24,4.5v-12a7.5,7.5,0,0,0-12-6\" +\n *         \"m-3,6v12a7.51,7.51,0,0,0,10.5,6.88\" +\n *         \"-3-17.38v9\"\n *     ));\n *\n *     Returns:\n *\n *     [\n *         M 0.75 17.25 a 16.5 16.5 0 0 1 27 -12.73,\n *         M 32.63 11.25 a 16.63 16.63 0 0 1 1.12 6 v 12 a 16.5 16.5 0 0 1 -16.5 16.5 a 16.82 16.82 0 0 1 -3 -0.27,\n *         M 6.75 42 a 16.49 16.49 0 0 1 -6 -12.73 v -4.5,\n *         M 24.75 29.27 v -12 a 7.5 7.5 0 0 0 -12 -6,\n *         M 9.75 17.27 v 12 a 7.51 7.51 0 0 0 10.5 6.88,\n *         M 17.25 18.77 v 9\n *     ]\n * @param   {string}    pathData    The SVG path data string.\n * @returns {Array}\n * @constructor\n */\nexport function PathSplitter(pathData) {\n  function paths(ps) {\n    var p = paths.ps = paths.ps || {};\n\n    if (p[ps]) {\n      p[ps].sleep = 100;\n    } else {\n      p[ps] = {\n        sleep: 100\n      };\n    }\n\n    setTimeout(function () {\n      for (var key in p) if (p.hasOwnProperty(key) && key !== ps) {\n        p[key].sleep--;\n        !p[key].sleep && delete p[key];\n      }\n    });\n    return p[ps];\n  }\n\n  function clone(obj) {\n    if (typeof obj == \"function\" || Object(obj) !== obj) {\n      return obj;\n    }\n\n    var res = new obj.constructor();\n\n    for (var key in obj) if (obj.hasOwnProperty(key)) {\n      res[key] = clone(obj[key]);\n    }\n\n    return res;\n  }\n\n  function pathClone(pathArray) {\n    var res = clone(pathArray);\n    res.toString = toString;\n    return res;\n  }\n\n  function parsePathString(pathString) {\n    if (!pathString) {\n      return null;\n    }\n\n    var pth = paths(pathString);\n\n    if (pth.arr) {\n      return pathClone(pth.arr);\n    }\n\n    var paramCounts = {\n      a: 7,\n      c: 6,\n      o: 2,\n      h: 1,\n      l: 2,\n      m: 2,\n      r: 4,\n      q: 4,\n      s: 4,\n      t: 2,\n      v: 1,\n      u: 3,\n      z: 0\n    },\n        data = [];\n\n    if (Array.isArray(pathString) && Array.isArray(pathString[0])) {\n      // rough assumption\n      data = pathClone(pathString);\n    }\n\n    if (!data.length) {\n      const pathCommand = /([a-z])[\\s,]*((-?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?[\\s]*,?[\\s]*)+)/gi;\n      const pathValues = /(-?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?)[\\s]*,?[\\s]*/gi;\n      String(pathString).replace(pathCommand, function (a, b, c) {\n        var params = [],\n            name = b.toLowerCase();\n        c.replace(pathValues, function (a, b) {\n          b && params.push(+b);\n        });\n\n        if (name === \"m\" && params.length > 2) {\n          data.push([b].concat(params.splice(0, 2)));\n          name = \"l\";\n          b = b === \"m\" ? \"l\" : \"L\";\n        }\n\n        if (name === \"o\" && params.length === 1) {\n          data.push([b, params[0]]);\n        }\n\n        if (name === \"r\") {\n          data.push([b].concat(params));\n        } else while (params.length >= paramCounts[name]) {\n          data.push([b].concat(params.splice(0, paramCounts[name])));\n\n          if (!paramCounts[name]) {\n            break;\n          }\n        }\n      });\n    }\n\n    data.toString = paths.toString;\n    pth.arr = pathClone(data);\n    return data;\n  }\n\n  function pathToAbsoluteSubPaths(path_string) {\n    var path_commands = parsePathString(path_string),\n        end_point = [0, 0],\n        sub_paths = [],\n        command = [],\n        i = 0;\n\n    while (i < path_commands.length) {\n      command = path_commands[i];\n      end_point = getNextEndPoint(end_point, command);\n\n      if (command[0] === \"m\") {\n        command = [\"M\", end_point[0], end_point[1]];\n      }\n\n      var sub_path = [command.join(\" \")];\n      i++;\n\n      while (!endSubPath(path_commands, i)) {\n        command = path_commands[i];\n        sub_path.push(command.join(\" \"));\n        end_point = getNextEndPoint(end_point, command);\n        i++;\n      }\n\n      sub_paths.push(sub_path.join(\" \"));\n    }\n\n    return sub_paths;\n  }\n\n  function getNextEndPoint(end_point, command) {\n    var x = end_point[0],\n        y = end_point[1];\n\n    if (isRelative(command)) {\n      switch (command[0]) {\n        case \"h\":\n          x += command[1];\n          break;\n\n        case \"v\":\n          y += command[1];\n          break;\n\n        case \"z\":\n          // back to [0,0]?\n          x = 0;\n          y = 0;\n          break;\n\n        default:\n          x += command[command.length - 2];\n          y += command[command.length - 1];\n      }\n    } else {\n      switch (command[0]) {\n        case \"H\":\n          x = command[1];\n          break;\n\n        case \"V\":\n          y = command[1];\n          break;\n\n        case \"Z\":\n          // back to [0,0]?\n          x = 0;\n          y = 0;\n          break;\n\n        default:\n          x = command[command.length - 2];\n          y = command[command.length - 1];\n      }\n    }\n\n    return [x, y];\n  }\n\n  function isRelative(command) {\n    return command[0] === command[0].toLowerCase();\n  }\n\n  function endSubPath(commands, index) {\n    if (index >= commands.length) {\n      return true;\n    } else {\n      return commands[index][0].toLowerCase() === \"m\";\n    }\n  }\n\n  return pathToAbsoluteSubPaths(pathData);\n}\n_c = PathSplitter;\n\nvar _c;\n\n$RefreshReg$(_c, \"PathSplitter\");","map":{"version":3,"sources":["/Users/mkumar18/dev/tools/svg-path-splitter/src/PathSplitter.js"],"names":["PathSplitter","pathData","paths","ps","p","sleep","setTimeout","key","hasOwnProperty","clone","obj","Object","res","constructor","pathClone","pathArray","toString","parsePathString","pathString","pth","arr","paramCounts","a","c","o","h","l","m","r","q","s","t","v","u","z","data","Array","isArray","length","pathCommand","pathValues","String","replace","b","params","name","toLowerCase","push","concat","splice","pathToAbsoluteSubPaths","path_string","path_commands","end_point","sub_paths","command","i","getNextEndPoint","sub_path","join","endSubPath","x","y","isRelative","commands","index"],"mappings":"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","sourcesContent":["/**\n * Reference - https://gist.github.com/iconifyit/958e7abba71806d663de6c2c273dc0da\n * This script was taken from a discussion on Google Groups.\n * I'm not taking credit for it but sharing it because it is very useful for splitting\n * discontinuous absolute paths into continuous subpaths. Where this is particularly\n * useful is for importing SVG files into applications like Figma, Sketch, InVision, XD, etc.\n */\n/**\n * Split discontinuous absolute paths into continuous sub-paths.\n *\n *     Example:\n *\n *     console.log(PathSplitter(\n *         \"M.75,17.25a16.5,16.5,0,0,1,27-12.73\" +\n *         \"m4.88,6.73a16.63,16.63,0,0,1,1.12,6v12a16.5,16.5,0,0,1-16.5,16.5,16.82,16.82,0,0,1-3-.27\" +\n *         \"M6.75,42a16.49,16.49,0,0,1-6-12.73v-4.5\" +\n *         \"m24,4.5v-12a7.5,7.5,0,0,0-12-6\" +\n *         \"m-3,6v12a7.51,7.51,0,0,0,10.5,6.88\" +\n *         \"-3-17.38v9\"\n *     ));\n *\n *     Returns:\n *\n *     [\n *         M 0.75 17.25 a 16.5 16.5 0 0 1 27 -12.73,\n *         M 32.63 11.25 a 16.63 16.63 0 0 1 1.12 6 v 12 a 16.5 16.5 0 0 1 -16.5 16.5 a 16.82 16.82 0 0 1 -3 -0.27,\n *         M 6.75 42 a 16.49 16.49 0 0 1 -6 -12.73 v -4.5,\n *         M 24.75 29.27 v -12 a 7.5 7.5 0 0 0 -12 -6,\n *         M 9.75 17.27 v 12 a 7.51 7.51 0 0 0 10.5 6.88,\n *         M 17.25 18.77 v 9\n *     ]\n * @param   {string}    pathData    The SVG path data string.\n * @returns {Array}\n * @constructor\n */\nexport function PathSplitter(pathData) {\n    function paths(ps) {\n        var p = (paths.ps = paths.ps || {});\n        if (p[ps]) {\n            p[ps].sleep = 100;\n        } else {\n            p[ps] = {\n                sleep: 100\n            };\n        }\n        setTimeout(function () {\n            for (var key in p)\n                if (p.hasOwnProperty(key) && key !== ps) {\n                    p[key].sleep--;\n                    !p[key].sleep && delete p[key];\n                }\n        });\n        return p[ps];\n    }\n\n    function clone(obj) {\n        if (typeof obj == \"function\" || Object(obj) !== obj) {\n            return obj;\n        }\n        var res = new obj.constructor();\n        for (var key in obj)\n            if (obj.hasOwnProperty(key)) {\n                res[key] = clone(obj[key]);\n            }\n        return res;\n    }\n\n    function pathClone(pathArray) {\n        var res = clone(pathArray);\n        res.toString = toString;\n        return res;\n    }\n\n    function parsePathString(pathString) {\n        if (!pathString) {\n            return null;\n        }\n        var pth = paths(pathString);\n        if (pth.arr) {\n            return pathClone(pth.arr);\n        }\n\n        var paramCounts = {\n                a: 7,\n                c: 6,\n                o: 2,\n                h: 1,\n                l: 2,\n                m: 2,\n                r: 4,\n                q: 4,\n                s: 4,\n                t: 2,\n                v: 1,\n                u: 3,\n                z: 0\n            },\n            data = [];\n        if (Array.isArray(pathString) && Array.isArray(pathString[0])) {\n            // rough assumption\n            data = pathClone(pathString);\n        }\n        if (!data.length) {\n            const pathCommand = /([a-z])[\\s,]*((-?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?[\\s]*,?[\\s]*)+)/gi;\n            const pathValues = /(-?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?)[\\s]*,?[\\s]*/gi;\n            String(pathString).replace(pathCommand, function (a, b, c) {\n                var params = [],\n                    name = b.toLowerCase();\n                c.replace(pathValues, function (a, b) {\n                    b && params.push(+b);\n                });\n                if (name === \"m\" && params.length > 2) {\n                    data.push([b].concat(params.splice(0, 2)));\n                    name = \"l\";\n                    b = b === \"m\" ? \"l\" : \"L\";\n                }\n                if (name === \"o\" && params.length === 1) {\n                    data.push([b, params[0]]);\n                }\n                if (name === \"r\") {\n                    data.push([b].concat(params));\n                } else\n                    while (params.length >= paramCounts[name]) {\n                        data.push(\n                            [b].concat(params.splice(0, paramCounts[name]))\n                        );\n                        if (!paramCounts[name]) {\n                            break;\n                        }\n                    }\n            });\n        }\n        data.toString = paths.toString;\n        pth.arr = pathClone(data);\n        return data;\n    }\n\n    function pathToAbsoluteSubPaths(path_string) {\n        var path_commands = parsePathString(path_string),\n            end_point = [0, 0],\n            sub_paths = [],\n            command = [],\n            i = 0;\n\n        while (i < path_commands.length) {\n            command = path_commands[i];\n            end_point = getNextEndPoint(end_point, command);\n            if (command[0] === \"m\") {\n                command = [\"M\", end_point[0], end_point[1]];\n            }\n            var sub_path = [command.join(\" \")];\n\n            i++;\n\n            while (!endSubPath(path_commands, i)) {\n                command = path_commands[i];\n                sub_path.push(command.join(\" \"));\n                end_point = getNextEndPoint(end_point, command);\n                i++;\n            }\n\n            sub_paths.push(sub_path.join(\" \"));\n        }\n\n        return sub_paths;\n    }\n\n    function getNextEndPoint(end_point, command) {\n        var x = end_point[0],\n            y = end_point[1];\n        if (isRelative(command)) {\n            switch (command[0]) {\n                case \"h\":\n                    x += command[1];\n                    break;\n                case \"v\":\n                    y += command[1];\n                    break;\n                case \"z\":\n                    // back to [0,0]?\n                    x = 0;\n                    y = 0;\n                    break;\n                default:\n                    x += command[command.length - 2];\n                    y += command[command.length - 1];\n            }\n        } else {\n            switch (command[0]) {\n                case \"H\":\n                    x = command[1];\n                    break;\n                case \"V\":\n                    y = command[1];\n                    break;\n                case \"Z\":\n                    // back to [0,0]?\n                    x = 0;\n                    y = 0;\n                    break;\n                default:\n                    x = command[command.length - 2];\n                    y = command[command.length - 1];\n            }\n        }\n        return [x, y];\n    }\n\n    function isRelative(command) {\n        return command[0] === command[0].toLowerCase();\n    }\n\n    function endSubPath(commands, index) {\n        if (index >= commands.length) {\n            return true;\n        } else {\n            return commands[index][0].toLowerCase() === \"m\";\n        }\n    }\n\n    return pathToAbsoluteSubPaths(pathData);\n}\n"]},"metadata":{},"sourceType":"module"}