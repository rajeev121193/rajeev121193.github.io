{"ast":null,"code":"import _toConsumableArray from\"/Users/mkumar18/dev/personal/rajeev121193.github.io/svg-path-splitter/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";import{PathSplitter}from\"./PathSplitter\";export function OptimizeSvg(inputFileUrl,outputFileSetter,imageDimensSetter){var request=new XMLHttpRequest();request.open(\"GET\",inputFileUrl);request.setRequestHeader(\"Content-Type\",\"image/svg+xml\");request.addEventListener(\"load\",function(event){var response=event.target.responseText;var doc=new DOMParser();var xml=doc.parseFromString(response,\"image/svg+xml\");imageDimensSetter(xml.width,xml.height);//This is to convert HTML collection to JS Array\nvar allPaths=_toConsumableArray(xml.getElementsByTagName(\"path\"));var oldPathToNewPathsMap={};allPaths.forEach(function(path,index){var parentNode=path.parentNode;var newPathNodes=[];PathSplitter(path.getAttribute(\"d\")).forEach(function(pathDataPart){var newPath=path.cloneNode(true);newPath.setAttribute(\"d\",pathDataPart);newPathNodes.push(newPath);});// Track all paths to be deleted and added for each parent\nvar existingData=oldPathToNewPathsMap[parentNode.toString()];if(existingData){oldPathToNewPathsMap[parentNode.toString()]={parentNode:parentNode,oldPathNodes:[].concat(_toConsumableArray(existingData.oldPathNodes),[path]),newPathNodes:[].concat(_toConsumableArray(existingData.newPathNodes),newPathNodes)};}else{oldPathToNewPathsMap[parentNode.toString()]={parentNode:parentNode,oldPathNodes:[path],newPathNodes:newPathNodes};}});// Delete all the old paths and add all the new paths for each parent\nObject.keys(oldPathToNewPathsMap).forEach(function(parentNodeKey){var _oldPathToNewPathsMap=oldPathToNewPathsMap[parentNodeKey],parentNode=_oldPathToNewPathsMap.parentNode,oldPathNodes=_oldPathToNewPathsMap.oldPathNodes,newPathNodes=_oldPathToNewPathsMap.newPathNodes;oldPathNodes.forEach(function(oldPath){return parentNode.removeChild(oldPath);});newPathNodes.forEach(function(newPath){return parentNode.appendChild(newPath);});});//Convert the new XML document to svg string\nvar svgData=new XMLSerializer().serializeToString(xml);outputFileSetter(svgData);});return request.send();}","map":{"version":3,"sources":["/Users/mkumar18/dev/personal/rajeev121193.github.io/svg-path-splitter/src/OptimizeSvg.js"],"names":["PathSplitter","OptimizeSvg","inputFileUrl","outputFileSetter","imageDimensSetter","request","XMLHttpRequest","open","setRequestHeader","addEventListener","event","response","target","responseText","doc","DOMParser","xml","parseFromString","width","height","allPaths","getElementsByTagName","oldPathToNewPathsMap","forEach","path","index","parentNode","newPathNodes","getAttribute","pathDataPart","newPath","cloneNode","setAttribute","push","existingData","toString","oldPathNodes","Object","keys","parentNodeKey","oldPath","removeChild","appendChild","svgData","XMLSerializer","serializeToString","send"],"mappings":"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","sourcesContent":["import {PathSplitter} from \"./PathSplitter\";\n\nexport function OptimizeSvg(inputFileUrl, outputFileSetter, imageDimensSetter) {\n    var request = new XMLHttpRequest();\n    request.open(\"GET\", inputFileUrl);\n    request.setRequestHeader(\"Content-Type\", \"image/svg+xml\");\n    request.addEventListener(\"load\", function (event) {\n        var response = event.target.responseText;\n        var doc = new DOMParser();\n        var xml = doc.parseFromString(response, \"image/svg+xml\");\n\n        imageDimensSetter(xml.width, xml.height);\n\n        //This is to convert HTML collection to JS Array\n        const allPaths = [...xml.getElementsByTagName(\"path\")];\n        const oldPathToNewPathsMap = {};\n        allPaths.forEach((path, index) => {\n            const parentNode = path.parentNode;\n            const newPathNodes = [];\n            PathSplitter(path.getAttribute(\"d\")).forEach(pathDataPart => {\n                const newPath = path.cloneNode(true);\n                newPath.setAttribute(\"d\", pathDataPart);\n                newPathNodes.push(newPath);\n            });\n\n            // Track all paths to be deleted and added for each parent\n            const existingData = oldPathToNewPathsMap[parentNode.toString()];\n            if (existingData) {\n                oldPathToNewPathsMap[parentNode.toString()] = {\n                    parentNode,\n                    oldPathNodes: [...existingData.oldPathNodes, path],\n                    newPathNodes: [\n                        ...existingData.newPathNodes,\n                        ...newPathNodes\n                    ]\n                };\n            } else {\n                oldPathToNewPathsMap[parentNode.toString()] = {\n                    parentNode,\n                    oldPathNodes: [path],\n                    newPathNodes: newPathNodes\n                };\n            }\n        });\n\n        // Delete all the old paths and add all the new paths for each parent\n        Object.keys(oldPathToNewPathsMap).forEach(parentNodeKey => {\n            const {\n                parentNode,\n                oldPathNodes,\n                newPathNodes\n            } = oldPathToNewPathsMap[parentNodeKey];\n            oldPathNodes.forEach(oldPath => parentNode.removeChild(oldPath));\n            newPathNodes.forEach(newPath => parentNode.appendChild(newPath));\n        });\n\n        //Convert the new XML document to svg string\n        var svgData = new XMLSerializer().serializeToString(xml);\n        outputFileSetter(svgData);\n    });\n    return request.send();\n}\n"]},"metadata":{},"sourceType":"module"}