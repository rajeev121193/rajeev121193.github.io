{"ast":null,"code":"/**\n * Reference - https://gist.github.com/iconifyit/958e7abba71806d663de6c2c273dc0da\n * This script was taken from a discussion on Google Groups.\n * I'm not taking credit for it but sharing it because it is very useful for splitting\n * discontinuous absolute paths into continuous subpaths. Where this is particularly\n * useful is for importing SVG files into applications like Figma, Sketch, InVision, XD, etc.\n */\n\n/**\n * Split discontinuous absolute paths into continuous sub-paths.\n *\n *     Example:\n *\n *     console.log(PathSplitter(\n *         \"M.75,17.25a16.5,16.5,0,0,1,27-12.73\" +\n *         \"m4.88,6.73a16.63,16.63,0,0,1,1.12,6v12a16.5,16.5,0,0,1-16.5,16.5,16.82,16.82,0,0,1-3-.27\" +\n *         \"M6.75,42a16.49,16.49,0,0,1-6-12.73v-4.5\" +\n *         \"m24,4.5v-12a7.5,7.5,0,0,0-12-6\" +\n *         \"m-3,6v12a7.51,7.51,0,0,0,10.5,6.88\" +\n *         \"-3-17.38v9\"\n *     ));\n *\n *     Returns:\n *\n *     [\n *         M 0.75 17.25 a 16.5 16.5 0 0 1 27 -12.73,\n *         M 32.63 11.25 a 16.63 16.63 0 0 1 1.12 6 v 12 a 16.5 16.5 0 0 1 -16.5 16.5 a 16.82 16.82 0 0 1 -3 -0.27,\n *         M 6.75 42 a 16.49 16.49 0 0 1 -6 -12.73 v -4.5,\n *         M 24.75 29.27 v -12 a 7.5 7.5 0 0 0 -12 -6,\n *         M 9.75 17.27 v 12 a 7.51 7.51 0 0 0 10.5 6.88,\n *         M 17.25 18.77 v 9\n *     ]\n * @requires {@link http://snapsvg.io}\n * @param   {string}    pathData    The SVG path data string.\n * @returns {Array}\n * @constructor\n */\nimport Snap from \"snapsvg\";\nexport function PathSplitter(pathData) {\n  function parsePathString(pathString) {\n    if (!pathString) {\n      return null;\n    }\n\n    var pth = Snap.path(pathString);\n\n    if (pth.arr) {\n      return Snap.path.clone(pth.arr);\n    }\n\n    var paramCounts = {\n      a: 7,\n      c: 6,\n      o: 2,\n      h: 1,\n      l: 2,\n      m: 2,\n      r: 4,\n      q: 4,\n      s: 4,\n      t: 2,\n      v: 1,\n      u: 3,\n      z: 0\n    },\n        data = [];\n\n    if (Array.isArray(pathString) && Array.isArray(pathString[0])) {\n      // rough assumption\n      data = Snap.path.clone(pathString);\n    }\n\n    if (!data.length) {\n      const pathCommand = /([a-z])[\\s,]*((-?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?[\\s]*,?[\\s]*)+)/gi;\n      const pathValues = /(-?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?)[\\s]*,?[\\s]*/gi;\n      String(pathString).replace(pathCommand, function (a, b, c) {\n        var params = [],\n            name = b.toLowerCase();\n        c.replace(pathValues, function (a, b) {\n          b && params.push(+b);\n        });\n\n        if (name === \"m\" && params.length > 2) {\n          data.push([b].concat(params.splice(0, 2)));\n          name = \"l\";\n          b = b == \"m\" ? \"l\" : \"L\";\n        }\n\n        if (name == \"o\" && params.length === 1) {\n          data.push([b, params[0]]);\n        }\n\n        if (name === \"r\") {\n          data.push([b].concat(params));\n        } else while (params.length >= paramCounts[name]) {\n          data.push([b].concat(params.splice(0, paramCounts[name])));\n\n          if (!paramCounts[name]) {\n            break;\n          }\n        }\n      });\n    }\n\n    data.toString = Snap.path.toString;\n    pth.arr = Snap.path.clone(data);\n    return data;\n  }\n\n  function pathToAbsoluteSubPaths(path_string) {\n    var path_commands = parsePathString(path_string),\n        end_point = [0, 0],\n        sub_paths = [],\n        command = [],\n        i = 0;\n\n    while (i < path_commands.length) {\n      command = path_commands[i];\n      end_point = getNextEndPoint(end_point, command);\n\n      if (command[0] === \"m\") {\n        command = [\"M\", end_point[0], end_point[1]];\n      }\n\n      var sub_path = [command.join(\" \")];\n      i++;\n\n      while (!endSubPath(path_commands, i)) {\n        command = path_commands[i];\n        sub_path.push(command.join(\" \"));\n        end_point = getNextEndPoint(end_point, command);\n        i++;\n      }\n\n      sub_paths.push(sub_path.join(\" \"));\n    }\n\n    return sub_paths;\n  }\n\n  function getNextEndPoint(end_point, command) {\n    var x = end_point[0],\n        y = end_point[1];\n\n    if (isRelative(command)) {\n      switch (command[0]) {\n        case \"h\":\n          x += command[1];\n          break;\n\n        case \"v\":\n          y += command[1];\n          break;\n\n        case \"z\":\n          // back to [0,0]?\n          x = 0;\n          y = 0;\n          break;\n\n        default:\n          x += command[command.length - 2];\n          y += command[command.length - 1];\n      }\n    } else {\n      switch (command[0]) {\n        case \"H\":\n          x = command[1];\n          break;\n\n        case \"V\":\n          y = command[1];\n          break;\n\n        case \"Z\":\n          // back to [0,0]?\n          x = 0;\n          y = 0;\n          break;\n\n        default:\n          x = command[command.length - 2];\n          y = command[command.length - 1];\n      }\n    }\n\n    return [x, y];\n  }\n\n  function isRelative(command) {\n    return command[0] === command[0].toLowerCase();\n  }\n\n  function endSubPath(commands, index) {\n    if (index >= commands.length) {\n      return true;\n    } else {\n      return commands[index][0].toLowerCase() === \"m\";\n    }\n  }\n\n  return pathToAbsoluteSubPaths(pathData);\n}\n_c = PathSplitter;\n\nvar _c;\n\n$RefreshReg$(_c, \"PathSplitter\");","map":{"version":3,"sources":["/Users/mkumar18/dev/tools/svg-path-splitter/src/PathSplitter.js"],"names":["Snap","PathSplitter","pathData","parsePathString","pathString","pth","path","arr","clone","paramCounts","a","c","o","h","l","m","r","q","s","t","v","u","z","data","Array","isArray","length","pathCommand","pathValues","String","replace","b","params","name","toLowerCase","push","concat","splice","toString","pathToAbsoluteSubPaths","path_string","path_commands","end_point","sub_paths","command","i","getNextEndPoint","sub_path","join","endSubPath","x","y","isRelative","commands","index"],"mappings":"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","sourcesContent":["/**\n * Reference - https://gist.github.com/iconifyit/958e7abba71806d663de6c2c273dc0da\n * This script was taken from a discussion on Google Groups.\n * I'm not taking credit for it but sharing it because it is very useful for splitting\n * discontinuous absolute paths into continuous subpaths. Where this is particularly\n * useful is for importing SVG files into applications like Figma, Sketch, InVision, XD, etc.\n */\n/**\n * Split discontinuous absolute paths into continuous sub-paths.\n *\n *     Example:\n *\n *     console.log(PathSplitter(\n *         \"M.75,17.25a16.5,16.5,0,0,1,27-12.73\" +\n *         \"m4.88,6.73a16.63,16.63,0,0,1,1.12,6v12a16.5,16.5,0,0,1-16.5,16.5,16.82,16.82,0,0,1-3-.27\" +\n *         \"M6.75,42a16.49,16.49,0,0,1-6-12.73v-4.5\" +\n *         \"m24,4.5v-12a7.5,7.5,0,0,0-12-6\" +\n *         \"m-3,6v12a7.51,7.51,0,0,0,10.5,6.88\" +\n *         \"-3-17.38v9\"\n *     ));\n *\n *     Returns:\n *\n *     [\n *         M 0.75 17.25 a 16.5 16.5 0 0 1 27 -12.73,\n *         M 32.63 11.25 a 16.63 16.63 0 0 1 1.12 6 v 12 a 16.5 16.5 0 0 1 -16.5 16.5 a 16.82 16.82 0 0 1 -3 -0.27,\n *         M 6.75 42 a 16.49 16.49 0 0 1 -6 -12.73 v -4.5,\n *         M 24.75 29.27 v -12 a 7.5 7.5 0 0 0 -12 -6,\n *         M 9.75 17.27 v 12 a 7.51 7.51 0 0 0 10.5 6.88,\n *         M 17.25 18.77 v 9\n *     ]\n * @requires {@link http://snapsvg.io}\n * @param   {string}    pathData    The SVG path data string.\n * @returns {Array}\n * @constructor\n */\nimport Snap from \"snapsvg\";\nexport function PathSplitter(pathData) {\n  function parsePathString(pathString) {\n    if (!pathString) {\n      return null;\n    }\n    var pth = Snap.path(pathString);\n    if (pth.arr) {\n      return Snap.path.clone(pth.arr);\n    }\n\n    var paramCounts = {\n        a: 7,\n        c: 6,\n        o: 2,\n        h: 1,\n        l: 2,\n        m: 2,\n        r: 4,\n        q: 4,\n        s: 4,\n        t: 2,\n        v: 1,\n        u: 3,\n        z: 0,\n      },\n      data = [];\n    if (Array.isArray(pathString) && Array.isArray(pathString[0])) {\n      // rough assumption\n      data = Snap.path.clone(pathString);\n    }\n    if (!data.length) {\n      const pathCommand = /([a-z])[\\s,]*((-?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?[\\s]*,?[\\s]*)+)/gi;\n      const pathValues = /(-?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?)[\\s]*,?[\\s]*/gi;\n      String(pathString).replace(pathCommand, function (a, b, c) {\n        var params = [],\n          name = b.toLowerCase();\n        c.replace(pathValues, function (a, b) {\n          b && params.push(+b);\n        });\n        if (name === \"m\" && params.length > 2) {\n          data.push([b].concat(params.splice(0, 2)));\n          name = \"l\";\n          b = b == \"m\" ? \"l\" : \"L\";\n        }\n        if (name == \"o\" && params.length === 1) {\n          data.push([b, params[0]]);\n        }\n        if (name === \"r\") {\n          data.push([b].concat(params));\n        } else\n          while (params.length >= paramCounts[name]) {\n            data.push([b].concat(params.splice(0, paramCounts[name])));\n            if (!paramCounts[name]) {\n              break;\n            }\n          }\n      });\n    }\n    data.toString = Snap.path.toString;\n    pth.arr = Snap.path.clone(data);\n    return data;\n  }\n  function pathToAbsoluteSubPaths(path_string) {\n    var path_commands = parsePathString(path_string),\n      end_point = [0, 0],\n      sub_paths = [],\n      command = [],\n      i = 0;\n\n    while (i < path_commands.length) {\n      command = path_commands[i];\n      end_point = getNextEndPoint(end_point, command);\n      if (command[0] === \"m\") {\n        command = [\"M\", end_point[0], end_point[1]];\n      }\n      var sub_path = [command.join(\" \")];\n\n      i++;\n\n      while (!endSubPath(path_commands, i)) {\n        command = path_commands[i];\n        sub_path.push(command.join(\" \"));\n        end_point = getNextEndPoint(end_point, command);\n        i++;\n      }\n\n      sub_paths.push(sub_path.join(\" \"));\n    }\n\n    return sub_paths;\n  }\n\n  function getNextEndPoint(end_point, command) {\n    var x = end_point[0],\n      y = end_point[1];\n    if (isRelative(command)) {\n      switch (command[0]) {\n        case \"h\":\n          x += command[1];\n          break;\n        case \"v\":\n          y += command[1];\n          break;\n        case \"z\":\n          // back to [0,0]?\n          x = 0;\n          y = 0;\n          break;\n        default:\n          x += command[command.length - 2];\n          y += command[command.length - 1];\n      }\n    } else {\n      switch (command[0]) {\n        case \"H\":\n          x = command[1];\n          break;\n        case \"V\":\n          y = command[1];\n          break;\n        case \"Z\":\n          // back to [0,0]?\n          x = 0;\n          y = 0;\n          break;\n        default:\n          x = command[command.length - 2];\n          y = command[command.length - 1];\n      }\n    }\n    return [x, y];\n  }\n\n  function isRelative(command) {\n    return command[0] === command[0].toLowerCase();\n  }\n\n  function endSubPath(commands, index) {\n    if (index >= commands.length) {\n      return true;\n    } else {\n      return commands[index][0].toLowerCase() === \"m\";\n    }\n  }\n\n  return pathToAbsoluteSubPaths(pathData);\n}\n"]},"metadata":{},"sourceType":"module"}