{"ast":null,"code":"import { PathSplitter } from \"./PathSplitter\";\nexport function OptimizeSvg(inputFileUrl, outputFileSetter, imageDimensSetter) {\n  var request = new XMLHttpRequest();\n  request.open(\"GET\", inputFileUrl);\n  request.setRequestHeader(\"Content-Type\", \"image/svg+xml\");\n  request.addEventListener(\"load\", function (event) {\n    var response = event.target.responseText;\n    var doc = new DOMParser();\n    var xml = doc.parseFromString(response, \"image/svg+xml\");\n    imageDimensSetter(xml.width, xml.height); //This is to convert HTML collection to JS Array\n\n    const allPaths = [...xml.getElementsByTagName(\"path\")];\n    const oldPathToNewPathsMap = {};\n    allPaths.forEach((path, index) => {\n      const parentNode = path.parentNode;\n      const newPathNodes = [];\n      PathSplitter(path.getAttribute(\"d\")).forEach(pathDataPart => {\n        const newPath = path.cloneNode(true);\n        newPath.setAttribute(\"d\", pathDataPart);\n        newPathNodes.push(newPath);\n      }); // Track all paths to be deleted and added for each parent\n\n      const existingData = oldPathToNewPathsMap[parentNode.toString()];\n\n      if (existingData) {\n        oldPathToNewPathsMap[parentNode.toString()] = {\n          parentNode,\n          oldPathNodes: [...existingData.oldPathNodes, path],\n          newPathNodes: [...existingData.newPathNodes, ...newPathNodes]\n        };\n      } else {\n        oldPathToNewPathsMap[parentNode.toString()] = {\n          parentNode,\n          oldPathNodes: [path],\n          newPathNodes: newPathNodes\n        };\n      }\n    }); // Delete all the old paths and add all the new paths for each parent\n\n    Object.keys(oldPathToNewPathsMap).forEach(parentNodeKey => {\n      const {\n        parentNode,\n        oldPathNodes,\n        newPathNodes\n      } = oldPathToNewPathsMap[parentNodeKey];\n      oldPathNodes.forEach(oldPath => parentNode.removeChild(oldPath));\n      newPathNodes.forEach(newPath => parentNode.appendChild(newPath));\n    }); //Convert the new XML document to svg string\n\n    var svgData = new XMLSerializer().serializeToString(xml);\n    outputFileSetter(svgData);\n  });\n  return request.send();\n}\n_c = OptimizeSvg;\n\nvar _c;\n\n$RefreshReg$(_c, \"OptimizeSvg\");","map":{"version":3,"sources":["/Users/mkumar18/dev/tools/svg-path-splitter/src/OptimizeSvg.js"],"names":["PathSplitter","OptimizeSvg","inputFileUrl","outputFileSetter","imageDimensSetter","request","XMLHttpRequest","open","setRequestHeader","addEventListener","event","response","target","responseText","doc","DOMParser","xml","parseFromString","width","height","allPaths","getElementsByTagName","oldPathToNewPathsMap","forEach","path","index","parentNode","newPathNodes","getAttribute","pathDataPart","newPath","cloneNode","setAttribute","push","existingData","toString","oldPathNodes","Object","keys","parentNodeKey","oldPath","removeChild","appendChild","svgData","XMLSerializer","serializeToString","send"],"mappings":"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","sourcesContent":["import {PathSplitter} from \"./PathSplitter\";\n\nexport function OptimizeSvg(inputFileUrl, outputFileSetter, imageDimensSetter) {\n    var request = new XMLHttpRequest();\n    request.open(\"GET\", inputFileUrl);\n    request.setRequestHeader(\"Content-Type\", \"image/svg+xml\");\n    request.addEventListener(\"load\", function (event) {\n        var response = event.target.responseText;\n        var doc = new DOMParser();\n        var xml = doc.parseFromString(response, \"image/svg+xml\");\n\n        imageDimensSetter(xml.width, xml.height);\n\n        //This is to convert HTML collection to JS Array\n        const allPaths = [...xml.getElementsByTagName(\"path\")];\n        const oldPathToNewPathsMap = {};\n        allPaths.forEach((path, index) => {\n            const parentNode = path.parentNode;\n            const newPathNodes = [];\n            PathSplitter(path.getAttribute(\"d\")).forEach(pathDataPart => {\n                const newPath = path.cloneNode(true);\n                newPath.setAttribute(\"d\", pathDataPart);\n                newPathNodes.push(newPath);\n            });\n\n            // Track all paths to be deleted and added for each parent\n            const existingData = oldPathToNewPathsMap[parentNode.toString()];\n            if (existingData) {\n                oldPathToNewPathsMap[parentNode.toString()] = {\n                    parentNode,\n                    oldPathNodes: [...existingData.oldPathNodes, path],\n                    newPathNodes: [\n                        ...existingData.newPathNodes,\n                        ...newPathNodes\n                    ]\n                };\n            } else {\n                oldPathToNewPathsMap[parentNode.toString()] = {\n                    parentNode,\n                    oldPathNodes: [path],\n                    newPathNodes: newPathNodes\n                };\n            }\n        });\n\n        // Delete all the old paths and add all the new paths for each parent\n        Object.keys(oldPathToNewPathsMap).forEach(parentNodeKey => {\n            const {\n                parentNode,\n                oldPathNodes,\n                newPathNodes\n            } = oldPathToNewPathsMap[parentNodeKey];\n            oldPathNodes.forEach(oldPath => parentNode.removeChild(oldPath));\n            newPathNodes.forEach(newPath => parentNode.appendChild(newPath));\n        });\n\n        //Convert the new XML document to svg string\n        var svgData = new XMLSerializer().serializeToString(xml);\n        outputFileSetter(svgData);\n    });\n    return request.send();\n}\n"]},"metadata":{},"sourceType":"module"}